<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="ES6," />










<meta name="description" content="let命令,const命令,变量解构赋值,解构赋值的用途,字符串的扩展,数值扩展,函数扩展,Symbol,Generator">
<meta name="keywords" content="ES6">
<meta property="og:type" content="article">
<meta property="og:title" content="ES2015新特性">
<meta property="og:url" content="http://yoursite.com/2018/01/30/es6/index.html">
<meta property="og:site_name" content="银河寒流">
<meta property="og:description" content="let命令,const命令,变量解构赋值,解构赋值的用途,字符串的扩展,数值扩展,函数扩展,Symbol,Generator">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-01-30T14:30:44.498Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES2015新特性">
<meta name="twitter:description" content="let命令,const命令,变量解构赋值,解构赋值的用途,字符串的扩展,数值扩展,函数扩展,Symbol,Generator">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/01/30/es6/"/>





  <title>ES2015新特性 | 银河寒流</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">银河寒流</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/30/es6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hubary">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="银河寒流">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ES2015新特性</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-30T20:22:44+08:00">
                2018-01-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES2015/" itemprop="url" rel="index">
                    <span itemprop="name">ES2015</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  let命令,const命令,变量解构赋值,解构赋值的用途,字符串的扩展,数值扩展,函数扩展,Symbol,Generator
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="es6-guide"><a href="#es6-guide" class="headerlink" title="es6-guide"></a>es6-guide</h2><h3 id="ECMAScript-6-学习笔记"><a href="#ECMAScript-6-学习笔记" class="headerlink" title="ECMAScript 6 学习笔记 "></a><center>ECMAScript 6 学习笔记 </center></h3><center><a href="http://es6.ruanyifeng.com/#docs/style" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/style</a></center>

<h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><ol>
<li>let声明的变量，只有所在的代码块内有效，let不像var一样，存在变量提升和函数提升现象</li>
<li><p>封闭作用域 只要块级作用域内存在let命令，它所声明的变量，不再受外部的影响，没有声明就不能使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var tmp =123;if(true)&#123;</span><br><span class="line">  tmp =&apos;abc&apos;; // ReferenceError</span><br><span class="line">let tmp;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在相同作用域内，let不允许同时声明一个变量</p>
</li>
<li>如果在严格模式下，函数只能在顶层作用域和函数内声明，其他情况（比如if代码块、循环代码块）的声明都会报错</li>
<li><p>let命令、const命令、class命令声明的全局变量，不属于全局对象的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a =1;</span><br><span class="line">// 如果在Node的REPL环境，可以写成global.a</span><br><span class="line">// 或者采用通用方法，写成this.a</span><br><span class="line">window.a // 1</span><br><span class="line">let b =1;</span><br><span class="line">window.b // undefined</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><ol>
<li>const也用来声明变量，但是声明的是常量,常量也是不提升的。一旦声明，常量的值就不能改变，对常量重新赋值不会报错，只会默默地失败</li>
</ol>
<h3 id="变量解构赋值"><a href="#变量解构赋值" class="headerlink" title="变量解构赋值"></a>变量解构赋值</h3><ol>
<li><p>模式匹配的写法，左边的变量会被赋予对应的值，解构赋值适用于var,let,const命令,ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let[x,, y]=[1,2,3];</span><br><span class="line">x // 1</span><br><span class="line">y // 3</span><br><span class="line">let[a,[b], d]=[1,[2,3],4];</span><br><span class="line">a // 1</span><br><span class="line">b // 2</span><br><span class="line">d // 4</span><br><span class="line">var&#123; bar, foo &#125;=&#123; foo:&quot;aaa&quot;, bar:&quot;bbb&quot;&#125;;</span><br><span class="line">foo // &quot;aaa&quot;</span><br><span class="line">bar // &quot;bbb&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6内部使用严格相等运算符（===），判断一个位置是否有值。只有那个位置上的值不严格等于undefined，才能解构赋值。对于没法解构的变量可以设置默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var[x =1]=[undefined];</span><br><span class="line">x // 1var[x =1]=[null];</span><br><span class="line">x // null</span><br><span class="line">var&#123;x =3&#125;=&#123;x: undefined&#125;;</span><br><span class="line">x // 3var&#123;x =3&#125;=&#123;x:null&#125;;</span><br><span class="line">x // null</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数的解构赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">functionmove(&#123;x =0, y =0&#125;=&#123;&#125;)&#123;return[x, y];&#125;move(&#123;x:3, y:8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x:3&#125;); // [3, 0]</span><br><span class="line">move(&#123;&#125;); // [0, 0]</span><br><span class="line">move(); // [0, 0]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="解构赋值的用途"><a href="#解构赋值的用途" class="headerlink" title="解构赋值的用途"></a>解构赋值的用途</h5><ol>
<li><p>交换变量的值</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数返回多个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function example()&#123;return[1,2,3];&#125;var[a, b, c]= example();</span><br><span class="line">// 返回一个对象</span><br><span class="line">function example()&#123;return&#123;</span><br><span class="line">    foo:1,</span><br><span class="line">    bar:2&#125;;</span><br><span class="line">&#125;</span><br><span class="line">var&#123; foo, bar &#125;= example();</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数的定义，函数调用时不用关注参数的顺序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 参数是一组无次序的值</span><br><span class="line">function f(&#123;x, y, z&#125;)&#123;...&#125;</span><br><span class="line">f(&#123;x:1, z:2, y:3&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>提取json数据，精简数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: &quot;OK&quot;,</span><br><span class="line">  data: [867, 5309]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let &#123; id, status, data: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line">console.log(id, status, number)</span><br><span class="line">// 42, OK, [867, 5309]</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置默认值,不需要如此设置默认值，var foo = config.foo || ‘default foo’;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  async =true,</span><br><span class="line">  beforeSend =function()&#123;&#125;,</span><br><span class="line">  cache =true,</span><br><span class="line">  complete =function()&#123;&#125;,</span><br><span class="line">  crossDomain =false,</span><br><span class="line">  global =true, // ... more config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历Map结构，实现了Iterator接口的对象都可以使用for of操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var map =newMap();</span><br><span class="line">map.set(&apos;first&apos;,&apos;hello&apos;);</span><br><span class="line">map.set(&apos;second&apos;,&apos;world&apos;);for(let[key, value] of map)&#123;</span><br><span class="line">  console.log(key +&quot; is &quot;+ value);&#125;</span><br><span class="line">// first is hello</span><br><span class="line">// second is world</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入模块的指定方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰</span><br><span class="line">const &#123; SourceMapConsumer, SourceNode &#125;=require(&quot;source-map&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><ol>
<li>String原型扩展<ul>
<li>stratsWith</li>
<li>endsWith</li>
<li>includes</li>
<li>repeat</li>
</ul>
</li>
<li><p>模板字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name =&quot;Bob&quot;, time =&quot;today&quot;;</span><br><span class="line">`Hello $&#123;name&#125;, \&apos;引号\&apos;how are you $&#123;time&#125;?` // Hello Bob, &apos;引号&apos;how are you today?</span><br><span class="line">$&#123;name&#125;作为插值，输出表达式结果</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><ol>
<li><p>Number</p>
<ul>
<li>Number.isFinite()用来检查一个数值是否非无穷（infinity）</li>
<li>Number.isNaN()用来检查一个值是否为NaN。</li>
<li>与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先进行类型装换，调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false</li>
<li>Number.parseInt(), Number.parseFloat(),全局方法parseInt()和parseFloat()行为完全保持不变</li>
<li>Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</li>
<li>Number.EPSILON 极小的常量Number.EPSILON</li>
<li>Number.isSafeInteger()准确表示的整数范围在-2^53到2^53之间（不含两个端点）</li>
</ul>
</li>
<li><p>新增指数运算符（<strong>, </strong>=）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2**2 // 4</span><br><span class="line">2**3 // 8</span><br><span class="line">let b =3;</span><br><span class="line">b **=3;</span><br><span class="line">// 等同于 b = b * b * b;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><ol>
<li><p>Array.form()</p>
<ul>
<li><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）比如arguments、NodeList和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）,任何有length属性的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&apos;hello&apos;)</span><br><span class="line"></span><br><span class="line">// [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]</span><br><span class="line">Array.from([1, 2, 3])</span><br><span class="line">// [1, 2, 3]</span><br><span class="line">let namesSet = new Set([&apos;a&apos;, &apos;b&apos;])</span><br><span class="line">Array.from(namesSet) // [&apos;a&apos;, &apos;b&apos;]</span><br><span class="line">let ps = document.querySelectorAll(&apos;p&apos;);</span><br><span class="line">Array.from(ps).forEach(function (p) &#123;</span><br><span class="line">    console.log(p);</span><br><span class="line">&#125;);</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var args = Array.from(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Array.from(arrayLike, x =&gt; x * x);</span><br><span class="line">// 等同于</span><br><span class="line">Array.from(arrayLike).map(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line">function typesOf () &#123;</span><br><span class="line">  return Array.from(arguments, value =&gt; typeof value)</span><br><span class="line">&#125;</span><br><span class="line">typesOf(null, [], NaN)</span><br><span class="line">// [&apos;object&apos;, &apos;object&apos;, &apos;number&apos;]</span><br><span class="line"></span><br><span class="line">Array.from(&#123; length: 2 &#125;, () =&gt; &apos;jack&apos;)</span><br><span class="line">// [&apos;jack&apos;, &apos;jack&apos;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Array.of()</p>
<ul>
<li>Array.of方法用于将一组值，转换为数组,Array.of基本上可以用来替代new Array()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.of(3, 11, 8) // [3,11,8]</span><br><span class="line">Array.of(3) // [3]</span><br><span class="line">Array.of(3).length // 1</span><br><span class="line">Array() // []</span><br><span class="line">Array(3) // [undefined, undefined, undefined]  //只有当参数个数不少于2个，Array()才会返回由参数组成的新数组</span><br><span class="line">Array(3, 11, 8) // [3, 11, 8]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>copyWithin()</p>
</li>
<li>find(), findIndex() <ul>
<li>用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员。indexOf 内部使用严格相当运算符（===）进行判断，这会导致对NaN的误判。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[NaN].indexOf(NaN)</span><br><span class="line">// -1</span><br><span class="line"></span><br><span class="line">[NaN].findIndex(y =&gt; Object.is(NaN, y))</span><br><span class="line">// 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol>
<li>fill()</li>
<li><p>entries()，keys()和values()</p>
<ul>
<li>用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</span><br><span class="line">  console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line"></span><br><span class="line">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">// &apos;a&apos;</span><br><span class="line">// &apos;b&apos;</span><br><span class="line"></span><br><span class="line">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">// 0 &quot;a&quot;</span><br><span class="line">// 1 &quot;b&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>includes() 数组是否包含给定的值</p>
</li>
<li><p>数组的空位</p>
<ul>
<li><p>数组的空位指，数组的某一个位置没有任何值，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 第一个数组的0号位置是有值的，第二个数组的0号位置没有值。</span><br><span class="line">0 in [undefined, undefined, undefined] // true</span><br><span class="line">0 in [, , ,] // false</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// forEach(), filter(), every() 和some()都会跳过空位。</span><br><span class="line">// forEach方法</span><br><span class="line">[,&apos;a&apos;].forEach((x,i) =&gt; log(i)); // 1</span><br><span class="line">// filter方法</span><br><span class="line">[&apos;a&apos;,,&apos;b&apos;].filter(x =&gt; true) // [&apos;a&apos;,&apos;b&apos;]</span><br><span class="line">// every方法</span><br><span class="line">[,&apos;a&apos;].every(x =&gt; x===&apos;a&apos;) // true</span><br><span class="line">// some方法</span><br><span class="line">[,&apos;a&apos;].some(x =&gt; x !== &apos;a&apos;) // false</span><br><span class="line">// map方法 map()会跳过空位，但会保留这个值</span><br><span class="line">[,&apos;a&apos;].map(x =&gt; 1) // [,1]</span><br><span class="line">// join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。</span><br><span class="line">// join方法 </span><br><span class="line">[,&apos;a&apos;,undefined,null].join(&apos;#&apos;) // &quot;#a##&quot;</span><br><span class="line">// toString方法</span><br><span class="line">[,&apos;a&apos;,undefined,null].toString() // &quot;,a,,&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6则是明确将空位转为undefined。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。</span><br><span class="line">Array.from([&apos;a&apos;,,&apos;b&apos;])</span><br><span class="line">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span><br><span class="line">扩展运算符（...）也会将空位转为undefined。</span><br><span class="line">[...[&apos;a&apos;,,&apos;b&apos;]]</span><br><span class="line">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span><br><span class="line">copyWithin()会连空位一起拷贝。</span><br><span class="line">[,&apos;a&apos;,&apos;b&apos;,,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;]</span><br><span class="line">fill()会将空位视为正常的数组位置。</span><br><span class="line">new Array(3).fill(&apos;a&apos;) // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</span><br><span class="line">entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。</span><br><span class="line">// entries()</span><br><span class="line">[...[,&apos;a&apos;].entries()] // [[0,undefined], [1,&quot;a&quot;]]</span><br><span class="line">// keys()</span><br><span class="line">[...[,&apos;a&apos;].keys()] // [0,1]</span><br><span class="line">// values()</span><br><span class="line">[...[,&apos;a&apos;].values()] // [undefined,&quot;a&quot;]</span><br><span class="line">// find()</span><br><span class="line">[,&apos;a&apos;].find(x =&gt; true) // undefined</span><br><span class="line">// findIndex()</span><br><span class="line">[,&apos;a&apos;].findIndex(x =&gt; true) // 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><em>空位的处理规则非常不统一，建议避免出现空位</em></p>
</li>
<li>数组推导(ES7)，可以等价于map()和filter()</li>
<li>Array.observe()，Array.unobserve()(ES7)，用于监听（取消监听）数组的变化，指定回调函数。</li>
</ol>
<h3 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h3><ol>
<li><p>函数默认值设置<br>参数默认值可以与解构赋值，联合起来使用，参数默认值可以与解构赋值，联合起来使用定义了默认值的参数，必须是函数的尾参数，其后不能再有其他无默认值的参数。这是因为有了默认值以后，该参数可以省略，只有位于尾部，才可能判断出到底省略了哪些参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ES6之前，当实参（0, &apos;&apos;）类型隐式转为false时，参数还是被设置成默认值，这不是我们想要的</span><br><span class="line">function log(x, y) &#123;</span><br><span class="line">  y = y || &apos;World&apos;;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello World</span><br><span class="line">log(&apos;Hello&apos;, 0) // Hello World</span><br><span class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</span><br><span class="line"></span><br><span class="line">ES6 实参为undefined，将触发该参数等于默认值，null则没有这个效果</span><br><span class="line">function log(x, y = &apos;World&apos;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello &apos;&apos;</span><br><span class="line">log(&apos;Hello&apos;, 0) // Hello 0</span><br><span class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</span><br></pre></td></tr></table></figure>
</li>
<li><p>reset参数<br>rest参数（形式为“…变量名”），rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错，用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中<br><strong>rest参数代替arguments变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// arguments变量的写法</span><br><span class="line">const sortNumbers = () =&gt;</span><br><span class="line">  Array.prototype.slice.call(arguments).sort();</span><br><span class="line"></span><br><span class="line">// rest参数的写法</span><br><span class="line">const sortNumbers = (...numbers) =&gt; numbers.sort();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 将剩余的实参包装成一个array-items</span><br><span class="line">function push(array, ...items) &#123;</span><br><span class="line">  items.forEach(function(item) &#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">    console.log(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = [];</span><br><span class="line">push(a, 1, 2, 3)</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展知识要点spread运算符(…)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">在函数新参中使用（reset参数的用法，items会初始化成数组）</span><br><span class="line">function push(array, ...items) &#123;</span><br><span class="line">  items.forEach(function(item) &#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">    console.log(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">var a = [];</span><br><span class="line">push(a, 1, 2, 3);</span><br><span class="line"></span><br><span class="line">const [first, ...rest] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];</span><br><span class="line">first // &quot;foo&quot;</span><br><span class="line">rest  // [&quot;bar&quot;,&quot;baz&quot;]</span><br><span class="line"></span><br><span class="line">操作数组，将一个数组转为用逗号分隔的参数序列</span><br><span class="line">var numbers = [4, 38];</span><br><span class="line">add(...numbers) // 42</span><br><span class="line">等同于</span><br><span class="line">add(4, 38) // 42</span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数=&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(a, b)=&gt;&#123; a + b &#125;</span><br><span class="line">等同于</span><br><span class="line">function(a, b)&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">参数只有一个时，()可以省略</span><br><span class="line">函数体只有一个语句时，&#123;&#125;可以省略</span><br></pre></td></tr></table></figure>
<p><strong>箭头函数有几个使用注意点</strong></p>
<ul>
<li>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象，<strong>在箭头函数中，它是固定的，不想其他函数可以通过bind设置</strong>。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</li>
<li>不可以使用yield命令，因此箭头函数不能用作Generator函数。</li>
</ul>
</li>
<li>函数绑定<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo::bar;</span><br><span class="line">// 等同于</span><br><span class="line">bar.call(foo);</span><br><span class="line"></span><br><span class="line">foo::bar(...arguments);</span><br><span class="line">i// 等同于</span><br><span class="line">bar.apply(foo, arguments);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><ol>
<li><p>属性的简洁表示法<br>ES6定义对象，允许只写属性名，这时候属性值等于属性名所代表的变量   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Person = &#123;</span><br><span class="line">  name: &apos;张三&apos;,</span><br><span class="line">  //等同于birth: birth</span><br><span class="line">  birth,</span><br><span class="line">  // 等同于hello: function ()...</span><br><span class="line">  hello() &#123; console.log(&apos;我的名字是&apos;, this.name); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性名表达式<br>ES6允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let propKey = &apos;foo&apos;;</span><br><span class="line">let obj = &#123;</span><br><span class="line">  [propKey]: true,</span><br><span class="line">  [&apos;a&apos; + &apos;bc&apos;]: 123</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法的name属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  get firstName() &#123;</span><br><span class="line">    return &quot;Nicholas&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.sayName.name   // &quot;sayName&quot;</span><br><span class="line">person.firstName.name // &quot;get firstName&quot;</span><br><span class="line">(new Function()).name // &quot;anonymous&quot;</span><br><span class="line"></span><br><span class="line">var doSomething = function() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br><span class="line">doSomething.bind().name // &quot;bound doSomething&quot;</span><br><span class="line">const key1 = Symbol(&apos;description&apos;);</span><br><span class="line">const key2 = Symbol();&#123;&#125;,</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">  [key1]()       [key2]() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj[key1].name // &quot;[description]&quot;</span><br><span class="line">obj[key2].name // &quot;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.is()<br>用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 不同之处</span><br><span class="line">+0 === -0 //true</span><br><span class="line">NaN === NaN // false</span><br><span class="line"></span><br><span class="line">Object.is(+0, -0) // false</span><br><span class="line">Object.is(NaN, NaN) // true</span><br></pre></td></tr></table></figure>
<ol>
<li>Object.assign()<br>Object.assign方法用来将源对象（source）的所有可枚举属性，复制到目标对象（target）。它至少需要两个对象作为参数，第一个参数是目标对象，后面的参数都是源对象。它只拷贝自身属性，不可枚举的属性（enumerable为false）和继承的属性不会被拷贝。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123; a: 1, b: 1 &#125;;</span><br><span class="line">var source1 = &#123; b: 2, c: 2 &#125;;</span><br><span class="line">var source2 = &#123; c: 3 &#125;;</span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>对于嵌套的对象，Object.assign的处理方法是替换，而不是添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123; a: &#123; b: &apos;c&apos;, d: &apos;e&apos; &#125; &#125;</span><br><span class="line">var source = &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;</span><br><span class="line">Object.assign(target, source)</span><br><span class="line">// &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;</span><br><span class="line">// 不会得到&#123; a: &#123; b: &apos;hello&apos;, d: &apos;e&apos; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>Object.assign的用处</strong></p>
<ul>
<li><p>为象添加属性和方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(SomeClass.prototype, &#123;</span><br><span class="line">  xxx,</span><br><span class="line">  anotherMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>克隆对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function clone(origin) &#123;</span><br><span class="line">  return Object.assign(&#123;&#125;, origin);</span><br><span class="line">&#125;</span><br><span class="line">// 克隆原型链上的属性    </span><br><span class="line">function clone(origin) &#123;</span><br><span class="line">  let originProto = Object.getPrototypeOf(origin);</span><br><span class="line">  return Object.assign(Object.create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并对象</p>
</li>
</ul>
</li>
<li><p>属性的可枚举性<br>描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。</p>
<p><strong>ES5有三个操作会忽略enumerable为false的属性。</strong></p>
<ul>
<li>for…in 循环：只遍历对象自身的和继承的可枚举的属性</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名</li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性</li>
</ul>
<p><strong>ES6新增了两个操作，会忽略enumerable为false的属性。</strong></p>
<ul>
<li>Object.assign()：只拷贝对象自身的可枚举的属性</li>
<li>Reflect.enumerate()：返回所有for…in循环会遍历的属性</li>
</ul>
<p>这五个操作之中，只有for…in和Reflect.enumerate()会返回继承的属性。实际上，引入enumerable的最初目的，就是让某些属性可以规避掉for…in操作。比如，对象原型的toString方法，以及数组的length属性，就通过这种手段，不会被for…in遍历到。</p>
</li>
<li><p><strong>proto</strong>属性，Object.setPrototypeOf()，Object.getPrototypeOf()<br>虽然目前，所有浏览器（包括IE11）都支持了<strong>proto</strong>这个属性，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替</p>
<p><strong>Object.setPrototypeOf()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let proto = &#123;&#125;;</span><br><span class="line">let obj = &#123; x: 10 &#125;;</span><br><span class="line">// obj.__proto__ = proto;</span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line">proto.y = 20;</span><br><span class="line">proto.z = 40;</span><br><span class="line">obj.x // 10</span><br><span class="line">obj.y // 20</span><br><span class="line">obj.z // 40</span><br></pre></td></tr></table></figure>
<p><strong>Object.getPrototypeOf()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Rectangle() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var rec = new Rectangle();</span><br><span class="line">Object.getPrototypeOf(rec) === Rectangle.prototype</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.observe()，Object.unobserve()<br>Object.observe方法目前共支持监听六种变化。<br>add：添加属性<br>update：属性值的变化<br>delete：删除属性<br>setPrototype：设置原型<br>reconfigure：属性的attributes对象发生变化<br>preventExtensions：对象被禁止扩展（当一个对象变得不可扩展时，也就不必再监听了）</p>
</li>
</ol>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）<br>Symbol不是一个构造器，不能用new操作符。Symbol函数的参数只是表示对当前Symbol值的描述，相同参数的Symbol函数的返回值是不相等的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 传参数是为了在控制台显示，或者转为字符串时，比较容易区分</span><br><span class="line">var s1 = Symbol(&apos;foo&apos;);</span><br><span class="line">var s2 = Symbol(&apos;bar&apos;);</span><br><span class="line">s1 // Symbol(foo)</span><br><span class="line">s2 // Symbol(bar)</span><br><span class="line">s1.toString() // &quot;Symbol(foo)&quot;</span><br><span class="line">s2.toString() // &quot;Symbol(bar)&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>作为属性名</strong><br>可以用表达式的地方就可以使用Symbol类型的变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var mySymbol = Symbol();</span><br><span class="line">// 第一种写法</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = &apos;Hello!&apos;;</span><br><span class="line">// 第二种写法</span><br><span class="line">var a = &#123;</span><br><span class="line">  [mySymbol]: &apos;Hello!&apos;</span><br><span class="line">&#125;;</span><br><span class="line">// 第三种写法</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">Object.defineProperty(a, mySymbol, &#123; value: &apos;Hello!&apos; &#125;);</span><br><span class="line">// 以上写法都得到同样结果</span><br><span class="line">a[mySymbol] // &quot;Hello!&quot;</span><br><span class="line"></span><br><span class="line">// a的结构</span><br><span class="line">Object &#123;Symbol(): &quot;Hello!&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>属性名的遍历</strong><br>Symbol类型的值作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var foo = Symbol(&quot;foo&quot;);</span><br><span class="line">Object.defineProperty(obj, foo, &#123;</span><br><span class="line">  value: &quot;foobar&quot;,</span><br><span class="line">&#125;);</span><br><span class="line">for (var i in obj) &#123;</span><br><span class="line">  console.log(i); // 无输出</span><br><span class="line">&#125;</span><br><span class="line">Object.getOwnPropertyNames(obj)</span><br><span class="line">// []</span><br><span class="line">Object.getOwnPropertySymbols(obj)</span><br><span class="line">// [Symbol(foo)]</span><br></pre></td></tr></table></figure></p>
<p>Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和Symbol键名<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    let obj = &#123;</span><br><span class="line">      [Symbol(&apos;my_key&apos;)]: 1,</span><br><span class="line">      enum: 2,</span><br><span class="line">      nonEnum: 3</span><br><span class="line">    &#125;;</span><br><span class="line">Reflect.ownKeys(obj)</span><br><span class="line">// [Symbol(my_key), &apos;enum&apos;, &apos;nonEnum&apos;]</span><br></pre></td></tr></table></figure></p>
<p><strong>Symbol.for()，Symbol.keyFor()</strong><br>Symbol.for接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Symbol.for(&quot;bar&quot;) === Symbol.for(&quot;bar&quot;)</span><br><span class="line">// true</span><br><span class="line">Symbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;)</span><br><span class="line">// false</span><br><span class="line"></span><br><span class="line">var s1 = Symbol.for(&quot;foo&quot;);</span><br><span class="line">Symbol.keyFor(s1) // &quot;foo&quot;</span><br><span class="line">var s2 = Symbol(&quot;foo&quot;);</span><br><span class="line">Symbol.keyFor(s2) // undefined</span><br></pre></td></tr></table></figure></p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy用于修改某些操作的默认行为,Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;; </span><br><span class="line">var proxy = new Proxy(obj, &#123;</span><br><span class="line">  get: function(target, property) &#123;</span><br><span class="line">    return 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.name  //undefined</span><br><span class="line">proxy.name // 35</span><br><span class="line">proxy.title // 35</span><br></pre></td></tr></table></figure>
<p>要使得Proxy起作用(handler中重载的方法)，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。支持Proxy支持的拦截操作的属性ES6定义了15个（get set has等）</p>
<p><strong>Proxy实例</strong><br><em>get</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: &quot;张三&quot;,</span><br><span class="line">  get age () &#123;</span><br><span class="line">    return 18;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">以上代码等同于</span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">var person = Object.defineProperties(&#123;</span><br><span class="line">  name: &quot;张三&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  age: &#123;</span><br><span class="line">    get: function get() &#123;</span><br><span class="line">      return 18;</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable: true,</span><br><span class="line">    enumerable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 对象每个属性都可以设置get，set。在赋值和取值是自动调用</span><br><span class="line"></span><br><span class="line">var proxy = new Proxy(person, &#123;</span><br><span class="line">  get: function(target, property) &#123;</span><br><span class="line">    if (property in target) &#123;</span><br><span class="line">      return target[property];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new ReferenceError(&quot;Property \&quot;&quot; + property + &quot;\&quot; does not exist.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 重写了obj.__proto__.get</span><br><span class="line">// 会代理所有属性的getter </span><br><span class="line"></span><br><span class="line">console.log(person.name) // &quot;张三&quot;</span><br><span class="line">console.log(person.age)  // 18</span><br><span class="line">console.log(proxy.name) // &quot;张三&quot;</span><br><span class="line">console.log(proxy.age) // 18</span><br><span class="line">console.log(proxy.address) // 抛出一个错误</span><br></pre></td></tr></table></figure></p>
<p><em>set</em><br>set方法用来拦截某个属性的赋值操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let validator = &#123;</span><br><span class="line">  set: function(obj, prop, value) &#123;</span><br><span class="line">    if (prop === &apos;age&apos;) &#123;</span><br><span class="line">      if (!Number.isInteger(value)) &#123;</span><br><span class="line">        throw new TypeError(&apos;The age is not an integer&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (value &gt; 200) &#123;</span><br><span class="line">        throw new RangeError(&apos;The age seems invalid&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对于age以外的属性，直接保存</span><br><span class="line">    obj[prop] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let person = new Proxy(&#123;&#125;, validator);</span><br><span class="line">person.age = 100;</span><br><span class="line">person.age // 100</span><br><span class="line">person.age = &apos;young&apos; // 报错</span><br><span class="line">person.age = 300 // 报错</span><br></pre></td></tr></table></figure></p>
<p><em>apply</em><br>apply方法拦截函数的调用、call和apply操作。代理一个function<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var twice = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    return Reflect.apply(...arguments) * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function sum (left, right) &#123;</span><br><span class="line">  return left + right;</span><br><span class="line">&#125;;</span><br><span class="line">var proxy = new Proxy(sum, twice);</span><br><span class="line">proxy(1, 2) // 6</span><br><span class="line">proxy.call(null, 5, 6) // 22</span><br><span class="line">proxy.apply(null, [7, 8]) // 30</span><br></pre></td></tr></table></figure></p>
<p><em>has</em><br>has方法可以隐藏某些属性，不被in操作符发现。</p>
<p><em>construct</em><br>construct方法用于拦截new命令。</p>
<p><em>deleteProperty</em><br>deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</p>
<p><em>defineProperty</em><br>defineProperty方法拦截了Object.defineProperty操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  defineProperty (target, key, descriptor) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var target = &#123;&#125;</span><br><span class="line">var proxy = new Proxy(target, handler)</span><br><span class="line">proxy.foo = &apos;bar&apos;</span><br><span class="line">// TypeError: proxy defineProperty handler returned false for property &apos;&quot;foo&quot;&apos;</span><br></pre></td></tr></table></figure></p>
<p><em>enumerate</em><br>enumerate方法用来拦截for…in循环。注意与Proxy对象的has方法区分，后者用来拦截in操作符，对for…in循环无效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  enumerate (target) &#123;</span><br><span class="line">    return Object.keys(target).filter(key =&gt; key[0] !== &apos;_&apos;)[Symbol.iterator]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var target = &#123; prop: &apos;foo&apos;, _bar: &apos;baz&apos;, _prop: &apos;foo&apos; &#125;</span><br><span class="line">var proxy = new Proxy(target, handler)</span><br><span class="line">for (let key in proxy) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;prop&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><ul>
<li>将Object对象的一些明显属于语言层面的方法，放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。</li>
<li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li>
<li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li>
<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，<em>不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Proxy(target, &#123;</span><br><span class="line">  set: function(target, name, value, receiver) &#123;</span><br><span class="line">    var success = Reflect.set(target,name, value, receiver);</span><br><span class="line">    if (success) &#123;</span><br><span class="line">      log(&apos;property &apos; + name + &apos; on &apos; + target + &apos; set to &apos; + value);</span><br><span class="line">    &#125;</span><br><span class="line">    return success;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><em>set</em><br>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。set内部判断两个值是否不同，使用的算法类似于精确相等运算符（===），这意味着，两个对象总是不相等的。唯一的例外是NaN等于自身（精确相等运算符认为NaN不等于自身）</p>
<p>Set结构的实例有以下属性</p>
<ul>
<li>Set.prototype.constructor：构造函数，默认就是Set函数。</li>
<li>Set.prototype.size：返回Set实例的成员总数。</li>
</ul>
<p>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>
<ul>
<li>add(value)：添加某个值，返回Set结构本身。</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
<p><em>WeakSet</em><br>WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。<br>首先，WeakSet的成员只能是对象，而不能是其他类型的值。<br>其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是只能用字符串当作键。这给它的使用带来了很大的限制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;&#125;;</span><br><span class="line">var element = document.getElementById(&quot;myDiv&quot;);</span><br><span class="line"></span><br><span class="line">data[element] = metadata;  </span><br><span class="line">// 等同于</span><br><span class="line">data[element.toString()] = metadata;  </span><br><span class="line">data[&quot;[Object HTMLDivElement]&quot;] // metadata</span><br></pre></td></tr></table></figure></p>
<p>ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。只有对同一个对象的引用，Map结构才将其视为同一个键。<br>遍历map<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map([</span><br><span class="line">  [&apos;F&apos;, &apos;no&apos;],</span><br><span class="line">  [&apos;T&apos;,  &apos;yes&apos;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">for (let key of map.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;F&quot;</span><br><span class="line">// &quot;T&quot;</span><br><span class="line"></span><br><span class="line">for (let value of map.values()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;no&quot;</span><br><span class="line">// &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">for (let item of map.entries()) &#123;</span><br><span class="line">  console.log(item[0], item[1]);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;F&quot; &quot;no&quot;</span><br><span class="line">// &quot;T&quot; &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">for (let [key, value] of map.entries()) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于使用map.entries()</span><br><span class="line">for (let [key, value] of map) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map.forEach(function(value, key, map)) &#123;</span><br><span class="line">  console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><em>与其他数据结构的互相转换</em></p>
<ul>
<li>Map转为数组</li>
<li>数组转为Map</li>
<li>Map转为对象</li>
<li>对象转为Map</li>
<li>Map转为JSON</li>
<li>JSON转为Map</li>
</ul>
<p><em>WeakMap</em><br>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</p>
<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><ul>
<li>四种数据集合 Array Object Set Map，<br>在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。<br>实现了Iterator接口，可以使用for..of..遍历<br>ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable） </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var array = [</span><br><span class="line">  1,</span><br><span class="line">  2,</span><br><span class="line">  3</span><br><span class="line">];</span><br><span class="line">var iterator = array[Symbol.iterator](); //返回Iterator类型的对象，有next方法</span><br><span class="line">iterator.next(); // &#123; value=1, done=false&#125;</span><br><span class="line">iterator.next(); // &#123; value=2 done=false&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><ul>
<li><p>基本概念<br>Generator函数是一个状态机，封装了多个内部状态。执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p>
</li>
<li><p>yield<br>Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。<br>遍历器对象的next方法的运行逻辑如下。</p>
<ol>
<li>遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li>
<li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。</li>
<li>如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li>
<li>如果该函数没有return语句，则返回的对象的value属性值为undefined。</li>
</ol>
</li>
<li><p>next方法的参数<br>yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* foo(x) &#123;</span><br><span class="line">  var y = 2 * (yield (x + 1));</span><br><span class="line">  var z = yield (y / 3);</span><br><span class="line">  return (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var it = foo(5);</span><br><span class="line"></span><br><span class="line">it.next()</span><br><span class="line">// &#123; value:6, done:false &#125;</span><br><span class="line">it.next(12)</span><br><span class="line">// &#123; value:8, done:false &#125;</span><br><span class="line">it.next(13)</span><br><span class="line">// &#123; value:42, done:true &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for…of循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function *foo() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">  yield 4;</span><br><span class="line">  yield 5;</span><br><span class="line">  return 6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let v of foo()) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">// 1 2 3 4 5</span><br></pre></td></tr></table></figure>
<p>一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for…of循环之中。</p>
</li>
<li><p>yield<em>语句<br>在Generater函数内部，调用另一个Generator函数<br>yield</em> 后面可以加Generator执行返回的遍历器对象，或者直接遍历器对象（Array）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* foo() &#123;</span><br><span class="line">  yield &apos;a&apos;;</span><br><span class="line">  yield &apos;b&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* bar() &#123;</span><br><span class="line">  yield &apos;x&apos;;</span><br><span class="line">  foo();</span><br><span class="line">  yield &apos;y&apos;;</span><br><span class="line">&#125;</span><br><span class="line">for (let v of bar())&#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;x&quot;</span><br><span class="line">// &quot;a&quot;</span><br><span class="line">// &quot;b&quot;</span><br><span class="line">// &quot;y&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用（Generator可以暂停函数执行，返回任意表达式的值）</p>
<ol>
<li>异步操作的同步化表达<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* main() &#123;</span><br><span class="line">  var result = yield request(&quot;http://some.url&quot;);</span><br><span class="line">  var resp = JSON.parse(result);</span><br><span class="line">    console.log(resp.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function request(url) &#123;</span><br><span class="line">  makeAjaxCall(url, function(response)&#123;</span><br><span class="line">    it.next(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var it = main();</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面代码的main函数，就是通过Ajax操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCall函数中的next方法，必须加上response参数，因为yield语句构成的表达式，本身是没有值的，总是等于undefined</p>
</li>
</ul>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。<br>Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。<br>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。</p>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署<br>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。<br>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用</p>
<ul>
<li>Promise对象实现的Ajax操作的例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var getJSON = function(url) &#123;</span><br><span class="line">  var promise = new Promise(function(resolve, reject)&#123;</span><br><span class="line">    var client = new XMLHttpRequest();</span><br><span class="line">    client.open(&quot;GET&quot;, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = &quot;json&quot;;</span><br><span class="line">    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">    function handler() &#123;</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        *resolve(this.response);*</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        *reject(new Error(this.statusText));*</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</span><br><span class="line">  console.log(&apos;Contents: &apos; + json);</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  console.error(&apos;出错了&apos;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>resolve函数的参数除了正常的值以外，还可能是另一个Promise实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p1和p2都是Promise的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</span><br><span class="line">注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是Pending，那么p2的回调函数就会等待p1的状态改变</span><br><span class="line"></span><br><span class="line">var p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; reject(new Error(&apos;fail&apos;)), 3000)</span><br><span class="line">&#125;)</span><br><span class="line">var p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; resolve(p1), 1000)    </span><br><span class="line">  // p2的状态由p1决定，虽然p2中调用了resolve，p1变为rejected，p2也跟着变为rejected</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(result =&gt; console.log(&apos;11&apos;), result =&gt; console.log(&apos;33&apos;))</span><br><span class="line">p1.catch(error =&gt; console.log(error))</span><br><span class="line">p2.then(result =&gt; console.log(&apos;22&apos;), result =&gt; console.log(&apos;44&apos;))</span><br><span class="line">p2.catch(error =&gt; console.log(error))</span><br><span class="line">// 33</span><br><span class="line">// fail</span><br><span class="line">// 44</span><br><span class="line">// fail</span><br><span class="line">p1是一个Promise，3秒之后变为rejected。p2的状态由p1决定，1秒之后，p2调用resolve方法，但是此时p1的状态还没有改变，因此p2的状态也不会变。又过了2秒，p1变为rejected，p2也跟着变为rejected。</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>Promise.prototype.then()<br>then方法返回的是一个新的Promise实例.<br>前一个promise的状态觉得后一个promise的状态，链式调用的时候，前一个回调函数返回的结构作为参数，传入后面那个回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;/post/1.json&quot;).then(</span><br><span class="line">  post =&gt; getJSON(post.commentURL)</span><br><span class="line">).then(</span><br><span class="line">  comments =&gt; console.log(&quot;Resolved: &quot;, comments),</span><br><span class="line">  err =&gt; console.log(&quot;Rejected: &quot;, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise.prototype.catch()<br>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.then((val) =&gt; console.log(&quot;fulfilled:&quot;, val))</span><br><span class="line">  .catch((err) =&gt; console.log(&quot;rejected:&quot;, err));</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">p.then((val) =&gt; console.log(fulfilled:&quot;, val))</span><br><span class="line">  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise.all()<br>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数不一定是数组，但是必须具有iterator接口，且返回的每个成员都是Promise实例。）</p>
<p>p的状态由p1、p2、p3决定，分成两种情况。</p>
<ol>
<li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li>
<li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</li>
</ol>
<ul>
<li>Promise.race()</li>
</ul>
<p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.race([p1,p2,p3]);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.race([</span><br><span class="line">  fetch(&apos;/resource-that-may-take-a-while&apos;),</span><br><span class="line">  new Promise(function (resolve, reject) &#123;</span><br><span class="line">    setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000)</span><br><span class="line">  &#125;)</span><br><span class="line">])</span><br><span class="line">p.then(response =&gt; console.log(response))</span><br><span class="line">p.catch(error =&gt; console.log(error))</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。</p>
<ul>
<li>Promise.resolve()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&apos;foo&apos;)</span><br><span class="line">// 等价于</span><br><span class="line">new Promise(resolve =&gt; resolve(&apos;foo&apos;))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Promise实例的状态从一生成就是Resolved，所以回调函数会立即执行</p>
<ul>
<li>应用<br>加载图片<br>我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const preloadImage = function (path) &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    var image = new Image();</span><br><span class="line">    image.onload  = resolve;</span><br><span class="line">    image.onerror = reject;</span><br><span class="line">    image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="异步操作和Async函数"><a href="#异步操作和Async函数" class="headerlink" title="异步操作和Async函数"></a>异步操作和Async函数</h3><p>ES6诞生以前，异步编程的方法，大概有下面四种。</p>
<pre><code>1. 回调函数 (settimeout,  requestanimationframe, readFile)
2. 事件监听 (ajax, on-click, on-load) 
3. 发布/订阅
4. Promise 对象
</code></pre><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ul>
<li><p>基本词法<br>ES5的构造函数Point，对应ES6的Point类的构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">typeof Point // &quot;function&quot;</span><br><span class="line"></span><br><span class="line">class Point &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString()&#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toValue()&#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  constructor()&#123;&#125;,</span><br><span class="line">  toString()&#123;&#125;,</span><br><span class="line">  toValue()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.name // &quot;Point&quot;</span><br></pre></td></tr></table></figure>
<p>prototype对象的constructor属性，直接指向“类”的本身，和ES5的概念是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point.prototype.constructor === Point // true</span><br></pre></td></tr></table></figure>
<p>ES6中，类的内部所有定义的方法，都是不可枚举的（enumerable）。和ES5不一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.keys(Point.prototype)</span><br><span class="line">// []</span><br><span class="line">Object.getOwnPropertyNames(Point.prototype)</span><br><span class="line">// [&quot;constructor&quot;,&quot;toString&quot;]</span><br><span class="line"></span><br><span class="line">var Point = function (x, y)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = function() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.keys(Point.prototype)</span><br><span class="line">// [&quot;toString&quot;]</span><br><span class="line">Object.getOwnPropertyNames(Point.prototype)</span><br><span class="line">// [&quot;constructor&quot;,&quot;toString&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    super(x, y); // 调用父类的constructor(x, y)</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>类的prototype属性和__proto__属性
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A // true</span><br><span class="line">B.prototype.__proto__ === A.prototype // true</span><br></pre></td></tr></table></figure>

Object.getPrototypeOf方法可以用来从子类上获取父类,判断，一个类是否继承了另一个类。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(ColorPoint) === Point</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li>Mixin模式的实现<br>Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class DistributedEdit extends mix(Loggable, Serializable) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ES6/" rel="tag"># ES6</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/05/18/sheji/" rel="next" title="设计模式">
                <i class="fa fa-chevron-left"></i> 设计模式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Hubary</p>
              <p class="site-description motion-element" itemprop="description">男人一定要顶天立地！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#es6-guide"><span class="nav-number">1.</span> <span class="nav-text">es6-guide</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ECMAScript-6-学习笔记"><span class="nav-number">1.1.</span> <span class="nav-text">ECMAScript 6 学习笔记 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#let命令"><span class="nav-number">1.2.</span> <span class="nav-text">let命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const命令"><span class="nav-number">1.3.</span> <span class="nav-text">const命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量解构赋值"><span class="nav-number">1.4.</span> <span class="nav-text">变量解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#解构赋值的用途"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">解构赋值的用途</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串的扩展"><span class="nav-number">1.5.</span> <span class="nav-text">字符串的扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值扩展"><span class="nav-number">1.6.</span> <span class="nav-text">数值扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组扩展"><span class="nav-number">1.7.</span> <span class="nav-text">数组扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数扩展"><span class="nav-number">1.8.</span> <span class="nav-text">函数扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象扩展"><span class="nav-number">1.9.</span> <span class="nav-text">对象扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol"><span class="nav-number">1.10.</span> <span class="nav-text">Symbol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy"><span class="nav-number">1.11.</span> <span class="nav-text">Proxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect"><span class="nav-number">1.12.</span> <span class="nav-text">Reflect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">1.13.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">1.14.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator"><span class="nav-number">1.15.</span> <span class="nav-text">Iterator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Generator"><span class="nav-number">1.16.</span> <span class="nav-text">Generator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise"><span class="nav-number">1.17.</span> <span class="nav-text">Promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步操作和Async函数"><span class="nav-number">1.18.</span> <span class="nav-text">异步操作和Async函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class"><span class="nav-number">1.19.</span> <span class="nav-text">Class</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hubary</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
